[{"name": "app.py", "content": "import numpy as np\n\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle, FancyArrowPatch\nimport matplotlib.lines as lines\n\nfrom scipy.integrate import quad\n\nfrom shiny import App, render, ui\nfrom shinyswatch.theme import flatly as shiny_theme # sandstone\n\nimport custom_styles as cs\nfrom physical_constants import *\n\n\nparams = {\n    'figure.figsize': cs.figsize_wholeslide,\n    'figure.dpi': 100,\n    'legend.fontsize': 16,\n    'axes.labelsize': 16,\n    'axes.titlesize': 16,\n    'xtick.labelsize':12,\n    'ytick.labelsize':12}\n\nplt.rcParams.update(params)\n\n\n\n# Define the UI\napp_ui = ui.page_navbar(\n    ui.nav_spacer(),  # Elements r\u00e9partis depuis la droite\n    ui.nav_panel(\"Position\".upper(),\n        ui.layout_columns(\n            ui.card(\"Param\u00e8tres\".upper(),\n                ui.input_slider(\"t3\", \"Temps:\", min=0, max=1, value=0, step=0.05, animate=ui.AnimationOptions(interval=500, loop=False)),\n                ui.input_slider(\"dt3\", \"Intervalle de temps:\", min=0.01, max=0.3, value=0.2),\n                ui.input_switch(\"dx3\", \"Vecteur d\u00e9placement\", value=False),\n                ui.input_switch(\"grid3\", \"Grille\", value=False),\n                ui.div(style=\"padding-bottom: 500px\"),\n            ),\n            ui.card(\"R\u00e9sultats\".upper(),\n                ui.output_plot(\"plotPosition\")\n            ),\n            col_widths=(2, 10),\n        ),     \n    ),\n    ui.nav_panel(\"Vitesse\".upper(),\n        ui.layout_columns(\n            ui.card(\"Param\u00e8tres\".upper(),\n                ui.input_slider(\"t2\", \"Temps:\", min=0, max=1, value=0),\n                ui.input_slider(\"dt2\", \"Intervalle de temps:\", min=0.01, max=1, value=1.00),\n                ui.input_switch(\"vecteur\", \"Vecteur vitesse\", value=False),\n                ui.div(style=\"padding-bottom: 500px\"),\n            ),\n            ui.card(\"R\u00e9sultats\".upper(),\n                ui.output_plot(\"plotVitesse\")\n            ),\n            col_widths=(2, 10),\n        ),     \n    ),\n    ui.nav_panel(\"Mouvement circulaire\".upper(),\n        ui.layout_columns(\n            ui.card(\"Param\u00e8tres\".upper(),\n                ui.input_slider(\"t1\", \"Temps:\", min=0, max=1, value=0),\n                ui.input_slider(\"dt1\", \"Intervalle de temps:\", min=0.01, max=1, value=1.00),\n                ui.input_slider(\"v1\", \"Vitesse scalaire\", min=0.0, max=1.0, value=0.5),\n                ui.input_slider(\"R1\", \"Rayon du cercle\", min=0.5, max=2.0, value=5.0),\n                ui.div(style=\"padding-bottom: 500px\"),\n            ),\n            ui.card(\"R\u00e9sultats\".upper(),\n                ui.output_plot(\"plotMCU\")\n            ),\n            col_widths=(2, 10),\n        ),     \n    ),\n    ui.nav_panel(\"Clotho\u00efde\".upper(),\n        ui.layout_columns(\n            ui.card(\"Param\u00e8tres\".upper(),\n                ui.input_slider(\"t4\", \"Temps:\", min=0.01, max=1, value=1.00),\n                ui.input_slider(\"R4\", \"Facteur g\u00e9om\u00e9trique\", min=0.5, max=1.0, value=1.0),\n                ui.input_slider(\"v4\", \"Vitesse scalaire\", min=0.5, max=2.0, value=1.0),\n                ui.input_switch(\"a_normale\", \"Vecteur acc\u00e9l\u00e9ration\", value=False),\n                ui.div(style=\"padding-bottom: 500px\"),\n            ),\n            ui.card(\"R\u00e9sultats\".upper(),\n                ui.output_plot(\"plotClothoide\")\n            ),\n            col_widths=(2, 10),\n        ),     \n    ),\n    title=\"Cin\u00e9matique\".upper(),\n    theme=shiny_theme,\n)\n\n# Define the server logic\ndef server(input, output, session):\n    @output\n\n    @render.plot()\n    def plotPosition():\n        gs_kw = dict(width_ratios=[1, 1], height_ratios=[1, 1])\n        fig, axs = plt.subplot_mosaic([[\"trajectoire\", \"rx\"], [\"trajectoire\", \"ry\"]], gridspec_kw=gs_kw, layout=\"tight\")\n\n        axs[\"trajectoire\"].set_xlim(-2.5, 2.5)\n        axs[\"trajectoire\"].set_ylim(-1, 3.5)\n\n        axs[\"trajectoire\"].set_xlabel(\"x (m)\")\n        axs[\"trajectoire\"].set_ylabel(\"y (m)\")\n\n        axs[\"trajectoire\"].scatter(0, 0, marker=\"X\", color=cs.bleufonc\u00e9)\n        axs[\"trajectoire\"].hlines(xmin=-2.5, xmax=2.5, y=0, color=\"k\", linewidth=1)\n        axs[\"trajectoire\"].vlines(x=0, ymin=-1, ymax=3.5, color=\"k\", linewidth=1)\n\n        axs[\"rx\"].set_xlim(0, 1)\n        #axs[\"rx\"].set_ylim(0, 2.5)\n        axs[\"rx\"].set_xticks([])\n        axs[\"rx\"].hlines(xmin=0, xmax=1, y=0, color=\"k\", linewidth=1)\n\n        axs[\"rx\"].set_ylabel(r\"$r_x$ (m)\")\n\n        axs[\"ry\"].set_xlim(0, 1)\n        #axs[\"rx\"].set_ylim(0, 2.5)\n\n        axs[\"ry\"].set_xlabel(\"Temps (s)\")\n        axs[\"ry\"].set_ylabel(r\"$r_y$ (m)\")\n        axs[\"ry\"].hlines(xmin=0, xmax=1, y=0, color=\"k\", linewidth=1)\n\n        def r(t):\n            x = 4 * (t - 0.5) + 0.8 * np.sin(4 * t)\n            y = 4 * (t - 0.15) + 1.2 * np.sin(6 * t)\n            return x, y\n\n        # Repr\u00e9sentation de la trajectoire\n        t = np.linspace(0, 1, 50)\n\n        x, y = r(t)\n        axs[\"trajectoire\"].plot(x, y, color=cs.bleufonc\u00e9, linestyle=\"--\")\n            \n        x0, y0 = r(input.t3())\n        #axs[\"trajectoire\"].scatter(x0, y0, color=cs.bleufonc\u00e9)\n\n        vect_r0 = FancyArrowPatch((0, 0), (x0, y0), arrowstyle='-|>', mutation_scale=10, color=cs.bleu, linewidth=2)\n        axs[\"trajectoire\"].add_patch(vect_r0)\n        axs[\"trajectoire\"].scatter(x0, y0, color=cs.bleu)\n\n        axs[\"rx\"].plot(t, x, color=cs.bleu)\n        axs[\"ry\"].plot(t, y, color=cs.bleu)\n        axs[\"rx\"].scatter(input.t3(), r(input.t3())[0], color=cs.bleu)        \n        axs[\"ry\"].scatter(input.t3(), r(input.t3())[1], color=cs.bleu)\n        axs[\"rx\"].vlines(x=input.t3(), ymin=0, ymax=r(input.t3())[0], colors=cs.bleu, linewidth=1, linestyle=\"--\")\n        axs[\"ry\"].vlines(x=input.t3(), ymin=0, ymax=r(input.t3())[1], colors=cs.bleu, linewidth=1, linestyle=\"--\")\n        axs[\"rx\"].hlines(xmin=0, xmax=input.t3(), y=r(input.t3())[0], colors=cs.bleu, linewidth=1, linestyle=\"--\")\n        axs[\"ry\"].hlines(xmin=0, xmax=input.t3(), y=r(input.t3())[1], colors=cs.bleu, linewidth=1, linestyle=\"--\")\n\n        if input.dx3():\n            x1, y1 = r(input.t3() + input.dt3())\n            axs[\"trajectoire\"].scatter(x1, y1, color=cs.bleufonc\u00e9)\n\n            vect_r1 = FancyArrowPatch((0, 0), (x1, y1), arrowstyle='-|>', mutation_scale=10, color=cs.bleu, linewidth=2)\n            axs[\"trajectoire\"].add_patch(vect_r1)\n\n            vect_dr = FancyArrowPatch((x0, y0), (x1, y1), arrowstyle='-|>', mutation_scale=10, color=cs.bleu, linewidth=2)\n            axs[\"trajectoire\"].add_patch(vect_dr)\n\n        if input.grid3():\n            axs[\"trajectoire\"].grid(True)\n        \n        return fig\n\n    @render.plot()\n    def plotVitesse():\n        gs_kw = dict(width_ratios=[1, 1], height_ratios=[1, 1])\n        fig, axs = plt.subplot_mosaic([[\"trajectoire\", \"vx\"], [\"trajectoire\", \"vy\"]], gridspec_kw=gs_kw, layout=\"tight\")\n\n        axs[\"trajectoire\"].set_xlim(-2.5, 2.5)\n        axs[\"trajectoire\"].set_ylim(-1, 3.5)\n\n        axs[\"trajectoire\"].set_xlabel(\"x (m)\")\n        axs[\"trajectoire\"].set_ylabel(\"y (m)\")\n\n        axs[\"trajectoire\"].scatter(0, 0, marker=\"X\", color=cs.bleufonc\u00e9)\n\n        axs[\"vx\"].set_xlim(0, 1)\n        #axs[\"vx\"].set_ylim(0, 2.5)\n        axs[\"vx\"].set_xticks([])\n\n        axs[\"vx\"].set_ylabel(r\"$v_x$ (m/s)\")\n\n        axs[\"vy\"].set_xlim(0, 1)\n        #axs[\"vx\"].set_ylim(0, 2.5)\n\n        axs[\"vy\"].set_xlabel(\"Temps (s)\")\n        axs[\"vy\"].set_ylabel(r\"$v_y$ (m/s)\")\n\n        def r(t):\n            x = 4 * (t - 0.5) + 0.1 * np.sin(2 * t)\n            y = 5 * (t - 0.15) + 1.2 * np.sin(6 * t)\n            return x, y\n        \n        def v(t):\n            vx = 4 + 0.1 * 2 * np.cos(2 * t)\n            vy = 5 + 1.2 * 6 * np.cos(6 * t)\n            return vx, vy\n\n        # Repr\u00e9sentation de la trajectoire\n        t = np.linspace(0, 1, 50)\n        x, y = r(t)\n        axs[\"trajectoire\"].plot(x, y, color=cs.bleufonc\u00e9, linestyle=\"--\")\n\n        if input.vecteur():\n            tt = np.linspace(0, 1, 10)\n            x, y = r(tt)\n            vx, vy = v(tt)\n\n            for xt, yt, vxt, vyt in zip(x, y, vx, vy):\n                vect_v = FancyArrowPatch((xt, yt), (xt + vxt / 10, yt + vyt / 10), arrowstyle='-|>', mutation_scale=10, color=cs.vert, linewidth=2)\n                axs[\"trajectoire\"].add_patch(vect_v)                \n\n        else:                \n            x0, y0 = r(input.t2())\n            axs[\"trajectoire\"].scatter(x0, y0, color=cs.bleufonc\u00e9)\n\n            vect_r0 = FancyArrowPatch((0, 0), (x0, y0), arrowstyle='-|>', mutation_scale=10, color=cs.bleu, linewidth=2)\n            axs[\"trajectoire\"].add_patch(vect_r0)\n\n            x1, y1 = r(input.t2() + input.dt2())\n            axs[\"trajectoire\"].scatter(x1, y1, color=cs.bleufonc\u00e9)\n\n            vect_r1 = FancyArrowPatch((0, 0), (x1, y1), arrowstyle='-|>', mutation_scale=10, color=cs.bleu, linewidth=2)\n            axs[\"trajectoire\"].add_patch(vect_r1)\n\n            vect_dr = FancyArrowPatch((x0, y0), (x1, y1), arrowstyle='-|>', mutation_scale=10, color=cs.bleu, linewidth=2)\n            axs[\"trajectoire\"].add_patch(vect_dr)\n\n            vx0 = (x1 - x0) / input.dt2() / 10 # Facteur d'\u00e9chelle\n            vy0 = (y1 - y0) / input.dt2() / 10 # Facteur d'\u00e9chelle\n            vect_drdt = FancyArrowPatch((x0, y0), (x0 + vx0, y0 + vy0), arrowstyle='-|>', mutation_scale=10, color=cs.vert, linewidth=2)\n            axs[\"trajectoire\"].add_patch(vect_drdt)\n\n        vx, vy = v(t)\n\n        axs[\"vx\"].plot(t, vx, color=cs.vert)\n        axs[\"vy\"].plot(t, vy, color=cs.vert)\n        axs[\"vx\"].scatter(input.t2(), v(input.t2())[0], color=cs.vert)        \n        axs[\"vy\"].scatter(input.t2(), v(input.t2())[1], color=cs.vert)\n\n        return fig\n\n    @render.plot()\n    def plotMCU():\n        fig, axs = plt.subplots(1, 2, figsize=cs.figsize_halfcolumn)\n\n        axs[0].set_xlim(-2.5, 2.5)\n        axs[0].set_ylim(-2.5, 2.5)\n\n        axs[0].set_xlabel(\"x (m)\")\n        axs[0].set_ylabel(\"y (m)\")\n\n        axs[0].scatter(0, 0, marker=\"X\", color=cs.bleufonc\u00e9)\n\n        axs[1].set_xlim(0, 1)\n        axs[1].set_ylim(0, 2.5)\n\n        axs[1].set_xlabel(\"Intervalle de temps (s)\")\n        axs[1].set_ylabel(\"Acc\u00e9l\u00e9ration (m/s)\")\n\n        # Coordonn\u00e9e des positions \u00e0 consid\u00e9rer\n        theta0 = input.v1() / input.R1() * input.t1()\n        x0 = input.R1() * np.cos(theta0)\n        y0 = input.R1() * np.sin(theta0)\n        v0x = input.v1() * (-np.sin(theta0))\n        v0y = input.v1() * (np.cos(theta0))\n\n        theta1 = theta0 + input.v1() / input.R1() * input.dt1()\n        x1 = input.R1() * np.cos(theta1)\n        y1 = input.R1() * np.sin(theta1)\n        v1x = input.v1() * (-np.sin(theta1))\n        v1y = input.v1() * (np.cos(theta1))\n\n        circle = Circle((0, 0), input.R1(), color=cs.bleufonc\u00e9, linewidth=2, linestyle=\"--\", fill=False)\n        axs[0].add_patch(circle)\n\n        line = lines.Line2D([0, x0], [0, y0], color=cs.bleufonc\u00e9, linewidth=1, linestyle=\":\", axes=axs[0])\n        axs[0].add_line(line)\n\n        vect_v0 = FancyArrowPatch((x0, y0), (x0 + v0x, y0 + v0y), arrowstyle='-|>', mutation_scale=10, color=cs.vert, linewidth=2)\n        axs[0].add_patch(vect_v0)\n        axs[0].scatter(x0, y0, color=cs.vert)\n\n        vect_v1 = FancyArrowPatch((x1, y1), (x1 + v1x, y1 + v1y), arrowstyle='-|>', mutation_scale=10, color=cs.vert, linewidth=2)\n        axs[0].add_patch(vect_v1)\n        axs[0].scatter(x1, y1, color=cs.vert)\n\n        dvx = v1x - v0x\n        dvy = v1y - v0y\n        dvdt0 = np.sqrt(dvx**2 + dvy**2)/input.dt1()\n\n        vect_dv = FancyArrowPatch((x0, y0), (x0 + dvx, y0 + dvy), arrowstyle='-|>', mutation_scale=10, color=cs.vert, linewidth=2)\n        axs[0].add_patch(vect_dv)\n\n        vect_a = FancyArrowPatch((x0, y0), (x0 + dvx / input.dt1(), y0 + dvy / input.dt1()), arrowstyle='-|>', mutation_scale=10, color=cs.violet, linewidth=2)        \n        axs[0].add_patch(vect_a)\n        \n        axs[0].set_aspect('equal', 'box')\n\n        # Acc\u00e9l\u00e9ration versus dt\n        dt = np.linspace(0.01, 1, 10)\n        dvdt = list()\n        for t in dt:\n            theta = theta0 + input.v1() / input.R1() * t\n            \n            dvx = input.v1() * (-np.sin(theta)) - v0x\n            dvy = input.v1() * (np.cos(theta)) - v0y\n\n            dvdt.append(np.sqrt(dvx**2 + dvy**2)/t)           \n        \n        axs[1].plot(dt, dvdt, color=cs.violet, label=\"dv/dt\")\n        axs[1].plot(dt, input.v1()**2 / input.R1() * np.ones_like(dt), color=cs.violet, linestyle=\":\", label=r\"$v^2/R$\")\n        axs[1].scatter(input.dt1(), dvdt0, color=cs.violet)\n        axs[1].legend()\n\n        return fig\n\n    @render.plot()\n    def plotClothoide():\n        gs_kw = dict(width_ratios=[1, 1], height_ratios=[1, 1])\n        fig, axs = plt.subplot_mosaic([[\"trajectoire\", \"l\"], [\"trajectoire\", \"an\"]], gridspec_kw=gs_kw, layout=\"tight\")\n\n        axs[\"trajectoire\"].set_xlim(0, 1)\n        axs[\"trajectoire\"].set_ylim(0, 1)\n\n        axs[\"trajectoire\"].set_xlabel(\"x (m)\")\n        axs[\"trajectoire\"].set_ylabel(\"y (m)\")\n\n        axs[\"l\"].set_xlim(0, 1)\n        #axs[\"l\"].set_ylim(0, 2.5)\n        axs[\"l\"].set_xticks([])\n\n        axs[\"l\"].set_ylabel(r\"$r_x$ (m)\")\n\n        axs[\"an\"].set_xlim(0, 1)\n        #axs[\"an\"].set_ylim(0, 2.5)\n\n        axs[\"an\"].set_xlabel(\"Temps (s)\")\n        axs[\"an\"].set_ylabel(r\"$r_y$ (m)\")\n\n        def clothoide(s, R):\n            C = quad(lambda u: np.cos(np.pi / 2 * u**2), 0, s)\n            S = quad(lambda u: np.sin(np.pi / 2 * u**2), 0, s)\n\n            return R * C[0], R * S[0]\n        \n        # Repr\u00e9sentation de la trajectoire\n        coef = input.v4() / input.R4()\n        tp = np.linspace(0.0, 1, 100)\n        t = input.v4() / input.R4() * np.linspace(0.0, 1, 10)\n\n        x = np.zeros_like(tp)\n        y = np.zeros_like(tp)\n\n        for id, tt in enumerate(tp):\n            xid, yid = clothoide(tt, input.R4())\n            x[id] = xid\n            y[id] = yid\n\n        axs[\"trajectoire\"].plot(x, y, color=cs.bleufonc\u00e9, linestyle=\"-\")\n            \n        x0, y0 = clothoide(coef * input.t4(), input.R4())\n        axs[\"trajectoire\"].scatter(x0, y0, color=cs.bleufonc\u00e9)\n\n        s = tp # input.v4() * tp / input.R4()**2\n        an_norm = np.pi * input.v4()**2 * s / input.R4()**2\n\n        axs[\"l\"].plot(t, input.v4() * t, color=cs.bleu, label=\"Distance parcourue\")\n        axs[\"l\"].plot(tp, np.pi * s / input.R4()**2, color=cs.bleu, label=\"Courbure\")\n\n        axs[\"an\"].plot(tp, an_norm, color=cs.violet)\n        #axs[\"l\"].legend(True)\n\n        if input.a_normale():\n            ex = -np.sin(np.pi / 2 * s**2 / input.R4()**2)\n            ey = np.cos(np.pi / 2 * s**2 / input.R4()**2)\n\n            an_norm = np.pi * input.v4()**2 * s / input.R4()**2\n\n            for xt, yt, ext, eyt, an_normt in zip(x, y, ex, ey, an_norm): \n                vect_a = FancyArrowPatch((xt, yt), (xt + an_normt * ext / 10, yt + an_normt * eyt / 10), arrowstyle='-|>', mutation_scale=10, color=cs.violet, linewidth=2)        \n                axs[\"trajectoire\"].add_patch(vect_a)\n       \n        return fig\n    \n# Create the app\napp = App(app_ui, server)\n", "type": "text"}]